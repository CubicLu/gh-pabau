## Paths

- `/prisma/` contains the latest `schema.prisma`  which lets us map and manipulate our current mariadb database using an object-oriented paradigm
- `/src/app/` contains the core business logic
- `/src/spec/` default dir for unit tests
- `/src/generated/` auto generated files by running ```yarn bridge:generate```
- `/src/middlewares/` GraphQl & Express.js middlewares
- `/src/schema/types/` All bespoke nexus objects not automatically generated by


# Running the bridge locally

Doing it the hard way cause u enjoy working with docker :(

Prerequisites:

The following section is for windows users only:
1. Docker desktop & WSL2 setup `https://docs.docker.com/docker-for-windows/wsl/`
2. Pull the latest build from our master branch `git pull origin master`
3. Hasura quick start with docker `https://www.google.com/search?q=hasura+docker&oq=hasura+docker&aqs=chrome.0.69i59j0l4j69i60l3.1492j0j7&sourceid=chrome&ie=UTF-8`
4. Once you have fully completed the above request and have access to our pabau_crm repo, follow the instruction to setup a local copy of pabau 1 node which includes our docker database. The guide can be found at: `https://bitbucket.org/pabau/pabau-crm/src/prelive/conf/pods/compose-images/node/`
5. After all the above steps have been completed open your local instance of docker desktop and ensure the following
  -   Docker is running and no errors are being shown
      U have both hasura and node running inside the container list
6. Rename apps/bridge-api/prisma/.env.SAMPLE to apps/bridge-api/prisma/.env [contact James, Toshe  or Kostova to get the latest valid JWT token]
7. `yarn nexus:generate` to generate the prisma client
8. If no errors were thrown `yarn nx serve bridge-api`
9. Navigate to http://localhost:8080/console > Remote Schemas > Add enter the following details to map the your local bridge-api instance created at step 8 with your local hasura docker container
   Name of schema: `bridge`
   Graphql Server URL: `http://docker.for.win.localhost:4000/graphql`
   Tick Forward all headers to the client
   Timeout in seconds `30`
   Click add remote schema
10. Navigate to the graphql tab and add the following headers
    - key: `authorization` 
   - value: `eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjo4Mzk4OCwiY29tcGFueSI6NDU1NSwiaHR0cHM6Ly9oYXN1cmEuaW8vand0L2NsYWltcyI6eyJ4LWhhc3VyYS1hbGxvd2VkLXJvbGVzIjpbInB1YmxpYyIsImFkbWluIl0sIngtaGFzdXJhLWRlZmF1bHQtcm9sZSI6InB1YmxpYyIsIngtaGFzdXJhLXVzZXItaWQiOiI4Mzk4OCIsIngtaGFzdXJhLW9yZy1pZCI6IjQ1NTUiLCJ4LWhhc3VyYS1qYW1lcyI6InRlc3QifSwiaWF0IjoxNjE1OTI5MzQyfQ.P0uIWtcjASpTGOdcoLeBaoggTsIq3wdi6L_3Zyx_yEP6FvoOnl9cNOAqvpZJLVQwLaSyaIuN7ksEbRE0DY9xIQ`

11. Ran the following test query to ensure everything is working correctly, expected response would be to get a response in the form of the logged in user
  `query {
    me {
      username
    }
  }`

12. Rename `apps/web/.env.SAMPLE` to `apps/web/.env.local` and uncomment the second  ENV variable `NEXT_PUBLIC_GRAPHQL_ENDPOINT`
13. `yarn nx serve dev` to run Pabau 2.0 locally and ensure everything is working as expected

Helpful links for potential links that may occur
1. The official docker documentation: `https://docs.docker.com/`
2. Windows Subsystem for linux`https://docs.microsoft.com/en-us/windows/wsl/install-win10`
3. `#pabau-2-dev` slack channel 

Easy way:
- If u prefer to use your pod database instead of a local docker img, contact [James, Toshe] 
- skip steps 1, 3,4, 9 and uncomment the first ENV variable at step 12


# The bridge 

Before working on the bridge-api please familiarise yourself with the following documentation and concepts
Everything has been preconfigured already but knowledge of the core concepts is recommended

- prisma `https://www.prisma.io/docs/concepts/components`
- nexus `https://nexusjs.org/docs/`
- ECMA script ES2017+

# Middlewares:

- Express.js middlewares `https://expressjs.com/en/guide/using-middleware.html` [used to intercept all server requests and authenticate/authorize/validate]
- Rule/Shield concepts `https://medium.com/@maticzav/graphql-shield-9d1e02520e35` [set or middleware function to be run in a specific order, used to inject data or validate a graphql query]
- Prisma middlewares `https://www.prisma.io/docs/concepts/components/prisma-client/middleware` [used to intercept the database calls]

# Resolvers:

Resolver : The function of the resolver is analog to the function of a controller in REST api's
Graphl Nexus resolvers concepts `https://nexusjs.org/docs/plugins/prisma/overview`

Your nexus resolvers are placed inside `apps/bridge-api/src/generated/types` 
Your business logic resolvers are placed inside `apps/bridge-api/src/schema/types`

# Running database queries inside your resolvers

Retrieving database data inside your resolvers example:
1. `ctx.query("Select id, remote_url from admin WHERE id = 8254)`
2. `ctx.prisma.user.findMany({
      where: {
        id: 8254,
    },`
    
Both of them serve the same underlying purpose, the benefit of the second approach is:

- more optimized complex queries
- eliminate developer mistake by preventing us running expensive operation on fields without a proper index

Benefit of the first approach is query usability from pabau and advanced analytic queries

# Debugging, tracing and performance optimization

While running the server in development mode u have access to a set of tools to debug and improve the performance of your queries 

1. Time of query execution in milliseconds for every executed query at the bridge. U can customize the information and complexity at at `apps/bridge-api/src/schema.ts`
   example query performance debug log: 
   `prisma:info  Fetched a connection from the pool
     Query: SELECT `pabau`.`marketing_sources`.`id`, `pabau`.`marketing_sources`.`source_name
     `, `pabau`.`marketing_sources`.`occupier`, `pabau`.`marketing_sources`.`custom_id`, `pab
     au`.`marketing_sources`.`public`, `pabau`.`marketing_sources`.`imported` FROM `pabau`.`m
     arketing_sources` WHERE (`pabau`.`marketing_sources`.`source_name` LIKE ? AND `pabau`.`m
     arketing_sources`.`public` = ? AND `pabau`.`marketing_sources`.`occupier` = ?) ORDER BY
     `pabau`.`marketing_sources`.`id` DESC LIMIT ? OFFSET ?
   Duration: 89ms`
2. `http://localhost:4000/graphql` > Enable tracing. To trace the Graphql response till full request completion rate

Improper usage of middlewares leads to request delays
Improper usage of context and queries leads to query performance issues
If in doubt should u write a regular query or use `ctx.prisma` to retrieve data, for the majority of the cases u should use the latter
Use the tools to your advantage. 

# Testing locally

`bash yarn && yarn nx deploy bridge-api && docker build --no-cache -t bridge -f tools/cicd/bridge.Dockerfile dist/apps/bridge-api/ && docker run --rm -it -p 4000:4000 bridge`

# Exposing GraphQL CRUD over a database table

Most of the time ORM remapping should be handled the following way

1.  Refer to the following sections before doing any changes
    - `https://www.prisma.io/docs/concepts/components/prisma-schema` detailed explanation on prisma.schema file and how it integrates with the underlying database
    - `https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/use-custom-model-and-field-names` using custom names for our models that mapping
2  Inside `apps/bridge-api/prisma/schema.prisma` locate the model that should be amended
    - Example: `company_id  Int     @map("occupier")` to map a new model property `company_id` to a database column `occupier`
    - Example: `company_id  Int` to use the same name for the both the model property name and the db column
3. `prisma validate` to ensure no typos/errors exist in our `schema.prisma`
4. Continue to the section `Initiate the client after successful changes and build types`

# Initiate the client after successful changes and build types

Easy way:
1. Run `yarn bridge:generate`

Complex way if errors arise

1. `prisma validate` [Validates the current `prisma.schema`]
2. `yarn bridge:prune` [Removes all auto generated files]
3. `prisma format` [Builds reverse model relationships]
4. `prisma generate` [Generates the prisma client and establishes a db connection] [`https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/generating-prisma-client`]
5. `pal g` [Auto Generated nexus types]
6. `pal schema typescript -o apps/bridge-api/src/generated` [Autogenerate interfaces for our prisma models]
7. `ts-node-dev --transpile-only apps/bridge-api/src/schema` [Compiles our nexus types into graphql schema]

Afterwards to ensure that the graphql queries/mutations where exposed properly
`nx serve bridge-api`

# Doing database modification

# [until introspect is implemented]

# Adding a new model property that maps to a newly created database column

1. Refer to the following prisma section before doing any significant work, `https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries`
2. Inside `apps/bridge-api/prisma/schema.prisma` locate the model that should be amended
3. example: `model Company { @@maps("admin") }` add a new database model based upon a new added database table
4. refer back to `Initiate the client after successful changes and build types`

# Adding model relationship

Examples from the `Company` model
1. 1-1 optional mapping from the `GlCode` model  `InvPaymentType InvPaymentType?      @relation(fields: [related_to], references: [id])`
2. 1-N mapping from the `Company` model `TwoFactorHistory TwoFactorHistory[]`
3. TODO composite keys mapping example

# Port mappings and relevant commands

1. `yarn nx serve bridge-api` runs at `localhost:4000/graphql`
2. `yarn nx serve backend` runs at `localhost:3000`
3. `yarn nx serve web` runs at `localhost:4200`
4. The hasura docker container is by default mapped to `localhost:8080/console`
5. Launch the full stack by running `yarn dev`

# Naming convention

We strongly recommend usage of the official graphql `http://spec.graphql.org/June2018` standard which applies to both our `schema.prisma` and our graphql resolvers
1. Naming our models properties in accordance to `http://spec.graphql.org/June2018/#sec-Language.Variables`
2. Naming our models in accordance to `http://spec.graphql.org/June2018/#sec-Names`
3. In doubt always fall back to the official graphql spec

Examples:

1. Your model, enum and property names should validate with the following regex `/[_A-Za-z][_0-9A-Za-z]*/` 
2. They should be singular `User` instead of `Users`
3. MUST not start with a number, no `2_factor_authentication`
4. Must not start with a special sign no `_id`

# Env files

1. `apps/bridge-api/prisma/.env` contains the jwt secret and the database cridentials
2. `apps/web/.env` contains the local bridge-api path which the frontend should connect to
   
# Relevant third-party modules documentation

- prisma `https://www.prisma.io/docs/concepts/components`
- nexus `https://nexusjs.org/docs/`
- pal.js `https://paljs.com/`
- hasura `https://hasura.io/docs/latest/graphql/core/getting-started/docker-simple.html`

# TODO quality of life dev improvements

1. docker-compose.yml for hasura - done in hasura/docker-compose.yml
2. Generate commands should list the files they overwrite
3. Use hasura cli-migrations to launch hasura with our schema
4. Each dev should have be able to remotly connect to a separate remote db
5. Docker deployment bug 

# Big ticket items
1. Node clustering for expensive queries, the server should replicate itself and create a separate node server that runs non a new thread on complex analytics queries
2. Proxy or dedicated communication with 2 separate instances of appolo client
3. cicd bug related to `https://github.com/prisma/prisma/issues/5304` or a

# Important

1. `nexus-plugin-prisma`, `nexus` `prisma` should always be kept not be updated automatically via `package.json`
2. `bridge.Dockerfile` should be kept at the same LTS version as the rest of the system


# Testing
# Common questions and bugs
# Hasura export
# Database migrations without using prisma introspect
# Introspection
